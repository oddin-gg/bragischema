// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.1
// 	protoc        v3.20.1
// source: bragi/dota2.proto

package bragi

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Dota2Faction int32

const (
	Dota2Faction_DOTA2_FACTION_UNSPECIFIED Dota2Faction = 0
	Dota2Faction_DOTA2_FACTION_RADIANT     Dota2Faction = 1
	Dota2Faction_DOTA2_FACTION_DIRE        Dota2Faction = 2
)

// Enum value maps for Dota2Faction.
var (
	Dota2Faction_name = map[int32]string{
		0: "DOTA2_FACTION_UNSPECIFIED",
		1: "DOTA2_FACTION_RADIANT",
		2: "DOTA2_FACTION_DIRE",
	}
	Dota2Faction_value = map[string]int32{
		"DOTA2_FACTION_UNSPECIFIED": 0,
		"DOTA2_FACTION_RADIANT":     1,
		"DOTA2_FACTION_DIRE":        2,
	}
)

func (x Dota2Faction) Enum() *Dota2Faction {
	p := new(Dota2Faction)
	*p = x
	return p
}

func (x Dota2Faction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Dota2Faction) Descriptor() protoreflect.EnumDescriptor {
	return file_bragi_dota2_proto_enumTypes[0].Descriptor()
}

func (Dota2Faction) Type() protoreflect.EnumType {
	return &file_bragi_dota2_proto_enumTypes[0]
}

func (x Dota2Faction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Dota2Faction.Descriptor instead.
func (Dota2Faction) EnumDescriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{0}
}

type Dota2Lane int32

const (
	Dota2Lane_DOTA2_LANE_UNSPECIFIED Dota2Lane = 0
	Dota2Lane_DOTA2_LANE_TOP         Dota2Lane = 1
	Dota2Lane_DOTA2_LANE_MID         Dota2Lane = 2
	Dota2Lane_DOTA2_LANE_BOT         Dota2Lane = 3
)

// Enum value maps for Dota2Lane.
var (
	Dota2Lane_name = map[int32]string{
		0: "DOTA2_LANE_UNSPECIFIED",
		1: "DOTA2_LANE_TOP",
		2: "DOTA2_LANE_MID",
		3: "DOTA2_LANE_BOT",
	}
	Dota2Lane_value = map[string]int32{
		"DOTA2_LANE_UNSPECIFIED": 0,
		"DOTA2_LANE_TOP":         1,
		"DOTA2_LANE_MID":         2,
		"DOTA2_LANE_BOT":         3,
	}
)

func (x Dota2Lane) Enum() *Dota2Lane {
	p := new(Dota2Lane)
	*p = x
	return p
}

func (x Dota2Lane) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Dota2Lane) Descriptor() protoreflect.EnumDescriptor {
	return file_bragi_dota2_proto_enumTypes[1].Descriptor()
}

func (Dota2Lane) Type() protoreflect.EnumType {
	return &file_bragi_dota2_proto_enumTypes[1]
}

func (x Dota2Lane) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Dota2Lane.Descriptor instead.
func (Dota2Lane) EnumDescriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{1}
}

type Dota2TowerTier int32

const (
	Dota2TowerTier_DOTA2_TOWER_TIER_UNSPECIFIED Dota2TowerTier = 0
	Dota2TowerTier_DOTA2_TOWER_TIER_1           Dota2TowerTier = 1
	Dota2TowerTier_DOTA2_TOWER_TIER_2           Dota2TowerTier = 2
	Dota2TowerTier_DOTA2_TOWER_TIER_3           Dota2TowerTier = 3
	Dota2TowerTier_DOTA2_TOWER_TIER_4           Dota2TowerTier = 4
)

// Enum value maps for Dota2TowerTier.
var (
	Dota2TowerTier_name = map[int32]string{
		0: "DOTA2_TOWER_TIER_UNSPECIFIED",
		1: "DOTA2_TOWER_TIER_1",
		2: "DOTA2_TOWER_TIER_2",
		3: "DOTA2_TOWER_TIER_3",
		4: "DOTA2_TOWER_TIER_4",
	}
	Dota2TowerTier_value = map[string]int32{
		"DOTA2_TOWER_TIER_UNSPECIFIED": 0,
		"DOTA2_TOWER_TIER_1":           1,
		"DOTA2_TOWER_TIER_2":           2,
		"DOTA2_TOWER_TIER_3":           3,
		"DOTA2_TOWER_TIER_4":           4,
	}
)

func (x Dota2TowerTier) Enum() *Dota2TowerTier {
	p := new(Dota2TowerTier)
	*p = x
	return p
}

func (x Dota2TowerTier) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Dota2TowerTier) Descriptor() protoreflect.EnumDescriptor {
	return file_bragi_dota2_proto_enumTypes[2].Descriptor()
}

func (Dota2TowerTier) Type() protoreflect.EnumType {
	return &file_bragi_dota2_proto_enumTypes[2]
}

func (x Dota2TowerTier) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Dota2TowerTier.Descriptor instead.
func (Dota2TowerTier) EnumDescriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{2}
}

type Dota2BarrackType int32

const (
	Dota2BarrackType_DOTA2_BARRACK_TYPE_UNSPECIFIED Dota2BarrackType = 0
	Dota2BarrackType_DOTA2_BARRACK_TYPE_RANGED      Dota2BarrackType = 1
	Dota2BarrackType_DOTA2_BARRACK_TYPE_MELEE       Dota2BarrackType = 2
)

// Enum value maps for Dota2BarrackType.
var (
	Dota2BarrackType_name = map[int32]string{
		0: "DOTA2_BARRACK_TYPE_UNSPECIFIED",
		1: "DOTA2_BARRACK_TYPE_RANGED",
		2: "DOTA2_BARRACK_TYPE_MELEE",
	}
	Dota2BarrackType_value = map[string]int32{
		"DOTA2_BARRACK_TYPE_UNSPECIFIED": 0,
		"DOTA2_BARRACK_TYPE_RANGED":      1,
		"DOTA2_BARRACK_TYPE_MELEE":       2,
	}
)

func (x Dota2BarrackType) Enum() *Dota2BarrackType {
	p := new(Dota2BarrackType)
	*p = x
	return p
}

func (x Dota2BarrackType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Dota2BarrackType) Descriptor() protoreflect.EnumDescriptor {
	return file_bragi_dota2_proto_enumTypes[3].Descriptor()
}

func (Dota2BarrackType) Type() protoreflect.EnumType {
	return &file_bragi_dota2_proto_enumTypes[3]
}

func (x Dota2BarrackType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Dota2BarrackType.Descriptor instead.
func (Dota2BarrackType) EnumDescriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{3}
}

type Dota2MatchMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MatchUrn   string                     `protobuf:"bytes,1,opt,name=match_urn,json=matchUrn,proto3" json:"match_urn,omitempty"`
	Sequence   uint64                     `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Timestamp  *timestamppb.Timestamp     `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	DataStatus DataStatus                 `protobuf:"varint,5,opt,name=data_status,json=dataStatus,proto3,enum=bragi.DataStatus" json:"data_status,omitempty"`
	Payload    *Dota2MatchMessage_Payload `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (x *Dota2MatchMessage) Reset() {
	*x = Dota2MatchMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchMessage) ProtoMessage() {}

func (x *Dota2MatchMessage) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchMessage.ProtoReflect.Descriptor instead.
func (*Dota2MatchMessage) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{0}
}

func (x *Dota2MatchMessage) GetMatchUrn() string {
	if x != nil {
		return x.MatchUrn
	}
	return ""
}

func (x *Dota2MatchMessage) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *Dota2MatchMessage) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *Dota2MatchMessage) GetDataStatus() DataStatus {
	if x != nil {
		return x.DataStatus
	}
	return DataStatus_DATA_STATUS_UNSPECIFIED
}

func (x *Dota2MatchMessage) GetPayload() *Dota2MatchMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

type Dota2MatchSnapshot struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MatchUrn      string                 `protobuf:"bytes,1,opt,name=match_urn,json=matchUrn,proto3" json:"match_urn,omitempty"`
	Sequence      uint64                 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	DataStatus    DataStatus             `protobuf:"varint,6,opt,name=data_status,json=dataStatus,proto3,enum=bragi.DataStatus" json:"data_status,omitempty"`
	Announcements []*Announcement        `protobuf:"bytes,4,rep,name=announcements,proto3" json:"announcements,omitempty"`
	MatchState    *Dota2MatchState       `protobuf:"bytes,5,opt,name=match_state,json=matchState,proto3" json:"match_state,omitempty"`
}

func (x *Dota2MatchSnapshot) Reset() {
	*x = Dota2MatchSnapshot{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchSnapshot) ProtoMessage() {}

func (x *Dota2MatchSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchSnapshot.ProtoReflect.Descriptor instead.
func (*Dota2MatchSnapshot) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{1}
}

func (x *Dota2MatchSnapshot) GetMatchUrn() string {
	if x != nil {
		return x.MatchUrn
	}
	return ""
}

func (x *Dota2MatchSnapshot) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *Dota2MatchSnapshot) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *Dota2MatchSnapshot) GetDataStatus() DataStatus {
	if x != nil {
		return x.DataStatus
	}
	return DataStatus_DATA_STATUS_UNSPECIFIED
}

func (x *Dota2MatchSnapshot) GetAnnouncements() []*Announcement {
	if x != nil {
		return x.Announcements
	}
	return nil
}

func (x *Dota2MatchSnapshot) GetMatchState() *Dota2MatchState {
	if x != nil {
		return x.MatchState
	}
	return nil
}

type Dota2MatchUpdate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Payload *Dota2MatchUpdate_Payload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (x *Dota2MatchUpdate) Reset() {
	*x = Dota2MatchUpdate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchUpdate) ProtoMessage() {}

func (x *Dota2MatchUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchUpdate.ProtoReflect.Descriptor instead.
func (*Dota2MatchUpdate) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{2}
}

func (x *Dota2MatchUpdate) GetPayload() *Dota2MatchUpdate_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

type Dota2MatchState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MatchUrn   string                `protobuf:"bytes,1,opt,name=match_urn,json=matchUrn,proto3" json:"match_urn,omitempty"`
	Scoreboard *Dota2MatchScoreboard `protobuf:"bytes,2,opt,name=scoreboard,proto3" json:"scoreboard,omitempty"`
	Minimap    *Dota2Minimap         `protobuf:"bytes,3,opt,name=minimap,proto3" json:"minimap,omitempty"`
}

func (x *Dota2MatchState) Reset() {
	*x = Dota2MatchState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchState) ProtoMessage() {}

func (x *Dota2MatchState) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchState.ProtoReflect.Descriptor instead.
func (*Dota2MatchState) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{3}
}

func (x *Dota2MatchState) GetMatchUrn() string {
	if x != nil {
		return x.MatchUrn
	}
	return ""
}

func (x *Dota2MatchState) GetScoreboard() *Dota2MatchScoreboard {
	if x != nil {
		return x.Scoreboard
	}
	return nil
}

func (x *Dota2MatchState) GetMinimap() *Dota2Minimap {
	if x != nil {
		return x.Minimap
	}
	return nil
}

type Dota2MatchScoreboard struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MatchUrn     string                `protobuf:"bytes,1,opt,name=match_urn,json=matchUrn,proto3" json:"match_urn,omitempty"`
	MapPaused    bool                  `protobuf:"varint,2,opt,name=map_paused,json=mapPaused,proto3" json:"map_paused,omitempty"`
	HomeTeamUrn  uint32                `protobuf:"varint,3,opt,name=home_team_urn,json=homeTeamUrn,proto3" json:"home_team_urn,omitempty"`
	AwayTeamUrn  uint32                `protobuf:"varint,4,opt,name=away_team_urn,json=awayTeamUrn,proto3" json:"away_team_urn,omitempty"`
	HomeScore    uint32                `protobuf:"varint,5,opt,name=home_score,json=homeScore,proto3" json:"home_score,omitempty"`
	AwayScore    uint32                `protobuf:"varint,6,opt,name=away_score,json=awayScore,proto3" json:"away_score,omitempty"`
	MatchStatus  MatchStatusType       `protobuf:"varint,7,opt,name=match_status,json=matchStatus,proto3,enum=bragi.MatchStatusType" json:"match_status,omitempty"`
	CurrentMap   *Dota2MapScoreboard   `protobuf:"bytes,8,opt,name=current_map,json=currentMap,proto3" json:"current_map,omitempty"`
	PreviousMaps []*Dota2MapScoreboard `protobuf:"bytes,9,rep,name=previous_maps,json=previousMaps,proto3" json:"previous_maps,omitempty"`
}

func (x *Dota2MatchScoreboard) Reset() {
	*x = Dota2MatchScoreboard{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchScoreboard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchScoreboard) ProtoMessage() {}

func (x *Dota2MatchScoreboard) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchScoreboard.ProtoReflect.Descriptor instead.
func (*Dota2MatchScoreboard) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{4}
}

func (x *Dota2MatchScoreboard) GetMatchUrn() string {
	if x != nil {
		return x.MatchUrn
	}
	return ""
}

func (x *Dota2MatchScoreboard) GetMapPaused() bool {
	if x != nil {
		return x.MapPaused
	}
	return false
}

func (x *Dota2MatchScoreboard) GetHomeTeamUrn() uint32 {
	if x != nil {
		return x.HomeTeamUrn
	}
	return 0
}

func (x *Dota2MatchScoreboard) GetAwayTeamUrn() uint32 {
	if x != nil {
		return x.AwayTeamUrn
	}
	return 0
}

func (x *Dota2MatchScoreboard) GetHomeScore() uint32 {
	if x != nil {
		return x.HomeScore
	}
	return 0
}

func (x *Dota2MatchScoreboard) GetAwayScore() uint32 {
	if x != nil {
		return x.AwayScore
	}
	return 0
}

func (x *Dota2MatchScoreboard) GetMatchStatus() MatchStatusType {
	if x != nil {
		return x.MatchStatus
	}
	return MatchStatusType_MATCH_STATUS_TYPE_UNSPECIFIED
}

func (x *Dota2MatchScoreboard) GetCurrentMap() *Dota2MapScoreboard {
	if x != nil {
		return x.CurrentMap
	}
	return nil
}

func (x *Dota2MatchScoreboard) GetPreviousMaps() []*Dota2MapScoreboard {
	if x != nil {
		return x.PreviousMaps
	}
	return nil
}

type Dota2MapScoreboard struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MapOrder uint32               `protobuf:"varint,1,opt,name=map_order,json=mapOrder,proto3" json:"map_order,omitempty"`
	GameTime *durationpb.Duration `protobuf:"bytes,2,opt,name=game_time,json=gameTime,proto3" json:"game_time,omitempty"`
	HomeTeam *Dota2TeamScoreboard `protobuf:"bytes,3,opt,name=home_team,json=homeTeam,proto3" json:"home_team,omitempty"`
	AwayTeam *Dota2TeamScoreboard `protobuf:"bytes,4,opt,name=away_team,json=awayTeam,proto3" json:"away_team,omitempty"`
}

func (x *Dota2MapScoreboard) Reset() {
	*x = Dota2MapScoreboard{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MapScoreboard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MapScoreboard) ProtoMessage() {}

func (x *Dota2MapScoreboard) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MapScoreboard.ProtoReflect.Descriptor instead.
func (*Dota2MapScoreboard) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{5}
}

func (x *Dota2MapScoreboard) GetMapOrder() uint32 {
	if x != nil {
		return x.MapOrder
	}
	return 0
}

func (x *Dota2MapScoreboard) GetGameTime() *durationpb.Duration {
	if x != nil {
		return x.GameTime
	}
	return nil
}

func (x *Dota2MapScoreboard) GetHomeTeam() *Dota2TeamScoreboard {
	if x != nil {
		return x.HomeTeam
	}
	return nil
}

func (x *Dota2MapScoreboard) GetAwayTeam() *Dota2TeamScoreboard {
	if x != nil {
		return x.AwayTeam
	}
	return nil
}

type Dota2TeamScoreboard struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TeamUrn  string                   `protobuf:"bytes,2,opt,name=team_urn,json=teamUrn,proto3" json:"team_urn,omitempty"`
	Faction  Dota2Faction             `protobuf:"varint,3,opt,name=faction,proto3,enum=bragi.Dota2Faction" json:"faction,omitempty"`
	Barracks uint32                   `protobuf:"varint,4,opt,name=barracks,proto3" json:"barracks,omitempty"`
	Kills    uint32                   `protobuf:"varint,5,opt,name=kills,proto3" json:"kills,omitempty"`
	NetWorth uint32                   `protobuf:"varint,6,opt,name=net_worth,json=netWorth,proto3" json:"net_worth,omitempty"`
	Roshans  uint32                   `protobuf:"varint,7,opt,name=roshans,proto3" json:"roshans,omitempty"`
	Towers   uint32                   `protobuf:"varint,8,opt,name=towers,proto3" json:"towers,omitempty"`
	Won      *bool                    `protobuf:"varint,9,opt,name=won,proto3,oneof" json:"won,omitempty"`
	Players  []*Dota2PlayerScoreboard `protobuf:"bytes,10,rep,name=players,proto3" json:"players,omitempty"`
}

func (x *Dota2TeamScoreboard) Reset() {
	*x = Dota2TeamScoreboard{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2TeamScoreboard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2TeamScoreboard) ProtoMessage() {}

func (x *Dota2TeamScoreboard) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2TeamScoreboard.ProtoReflect.Descriptor instead.
func (*Dota2TeamScoreboard) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{6}
}

func (x *Dota2TeamScoreboard) GetTeamUrn() string {
	if x != nil {
		return x.TeamUrn
	}
	return ""
}

func (x *Dota2TeamScoreboard) GetFaction() Dota2Faction {
	if x != nil {
		return x.Faction
	}
	return Dota2Faction_DOTA2_FACTION_UNSPECIFIED
}

func (x *Dota2TeamScoreboard) GetBarracks() uint32 {
	if x != nil {
		return x.Barracks
	}
	return 0
}

func (x *Dota2TeamScoreboard) GetKills() uint32 {
	if x != nil {
		return x.Kills
	}
	return 0
}

func (x *Dota2TeamScoreboard) GetNetWorth() uint32 {
	if x != nil {
		return x.NetWorth
	}
	return 0
}

func (x *Dota2TeamScoreboard) GetRoshans() uint32 {
	if x != nil {
		return x.Roshans
	}
	return 0
}

func (x *Dota2TeamScoreboard) GetTowers() uint32 {
	if x != nil {
		return x.Towers
	}
	return 0
}

func (x *Dota2TeamScoreboard) GetWon() bool {
	if x != nil && x.Won != nil {
		return *x.Won
	}
	return false
}

func (x *Dota2TeamScoreboard) GetPlayers() []*Dota2PlayerScoreboard {
	if x != nil {
		return x.Players
	}
	return nil
}

type Dota2PlayerScoreboard struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PlayerUrn    string               `protobuf:"bytes,1,opt,name=player_urn,json=playerUrn,proto3" json:"player_urn,omitempty"`
	SlotId       uint32               `protobuf:"varint,10,opt,name=slot_id,json=slotId,proto3" json:"slot_id,omitempty"`
	ExtName      string               `protobuf:"bytes,2,opt,name=ext_name,json=extName,proto3" json:"ext_name,omitempty"`
	HeroId       uint32               `protobuf:"varint,3,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HasAegis     bool                 `protobuf:"varint,4,opt,name=has_aegis,json=hasAegis,proto3" json:"has_aegis,omitempty"`
	RespawnTimer *durationpb.Duration `protobuf:"bytes,5,opt,name=respawn_timer,json=respawnTimer,proto3,oneof" json:"respawn_timer,omitempty"`
	Assists      uint32               `protobuf:"varint,6,opt,name=assists,proto3" json:"assists,omitempty"`
	Deaths       uint32               `protobuf:"varint,7,opt,name=deaths,proto3" json:"deaths,omitempty"`
	Kills        uint32               `protobuf:"varint,8,opt,name=kills,proto3" json:"kills,omitempty"`
	NetWorth     uint32               `protobuf:"varint,9,opt,name=net_worth,json=netWorth,proto3" json:"net_worth,omitempty"`
}

func (x *Dota2PlayerScoreboard) Reset() {
	*x = Dota2PlayerScoreboard{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2PlayerScoreboard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2PlayerScoreboard) ProtoMessage() {}

func (x *Dota2PlayerScoreboard) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2PlayerScoreboard.ProtoReflect.Descriptor instead.
func (*Dota2PlayerScoreboard) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{7}
}

func (x *Dota2PlayerScoreboard) GetPlayerUrn() string {
	if x != nil {
		return x.PlayerUrn
	}
	return ""
}

func (x *Dota2PlayerScoreboard) GetSlotId() uint32 {
	if x != nil {
		return x.SlotId
	}
	return 0
}

func (x *Dota2PlayerScoreboard) GetExtName() string {
	if x != nil {
		return x.ExtName
	}
	return ""
}

func (x *Dota2PlayerScoreboard) GetHeroId() uint32 {
	if x != nil {
		return x.HeroId
	}
	return 0
}

func (x *Dota2PlayerScoreboard) GetHasAegis() bool {
	if x != nil {
		return x.HasAegis
	}
	return false
}

func (x *Dota2PlayerScoreboard) GetRespawnTimer() *durationpb.Duration {
	if x != nil {
		return x.RespawnTimer
	}
	return nil
}

func (x *Dota2PlayerScoreboard) GetAssists() uint32 {
	if x != nil {
		return x.Assists
	}
	return 0
}

func (x *Dota2PlayerScoreboard) GetDeaths() uint32 {
	if x != nil {
		return x.Deaths
	}
	return 0
}

func (x *Dota2PlayerScoreboard) GetKills() uint32 {
	if x != nil {
		return x.Kills
	}
	return 0
}

func (x *Dota2PlayerScoreboard) GetNetWorth() uint32 {
	if x != nil {
		return x.NetWorth
	}
	return 0
}

type Dota2Minimap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MatchUrn  string                 `protobuf:"bytes,1,opt,name=match_urn,json=matchUrn,proto3" json:"match_urn,omitempty"`
	MapOrder  uint32                 `protobuf:"varint,2,opt,name=map_order,json=mapOrder,proto3" json:"map_order,omitempty"`
	MapPaused bool                   `protobuf:"varint,3,opt,name=map_paused,json=mapPaused,proto3" json:"map_paused,omitempty"`
	Towers    []*Dota2MinimapTower   `protobuf:"bytes,4,rep,name=towers,proto3" json:"towers,omitempty"`
	Barracks  []*Dota2MinimapBarrack `protobuf:"bytes,5,rep,name=barracks,proto3" json:"barracks,omitempty"`
}

func (x *Dota2Minimap) Reset() {
	*x = Dota2Minimap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2Minimap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2Minimap) ProtoMessage() {}

func (x *Dota2Minimap) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2Minimap.ProtoReflect.Descriptor instead.
func (*Dota2Minimap) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{8}
}

func (x *Dota2Minimap) GetMatchUrn() string {
	if x != nil {
		return x.MatchUrn
	}
	return ""
}

func (x *Dota2Minimap) GetMapOrder() uint32 {
	if x != nil {
		return x.MapOrder
	}
	return 0
}

func (x *Dota2Minimap) GetMapPaused() bool {
	if x != nil {
		return x.MapPaused
	}
	return false
}

func (x *Dota2Minimap) GetTowers() []*Dota2MinimapTower {
	if x != nil {
		return x.Towers
	}
	return nil
}

func (x *Dota2Minimap) GetBarracks() []*Dota2MinimapBarrack {
	if x != nil {
		return x.Barracks
	}
	return nil
}

type Dota2MinimapTower struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Lane    Dota2Lane      `protobuf:"varint,1,opt,name=lane,proto3,enum=bragi.Dota2Lane" json:"lane,omitempty"`
	Faction Dota2Faction   `protobuf:"varint,2,opt,name=faction,proto3,enum=bragi.Dota2Faction" json:"faction,omitempty"`
	Tier    Dota2TowerTier `protobuf:"varint,3,opt,name=tier,proto3,enum=bragi.Dota2TowerTier" json:"tier,omitempty"`
	Alive   bool           `protobuf:"varint,4,opt,name=alive,proto3" json:"alive,omitempty"`
}

func (x *Dota2MinimapTower) Reset() {
	*x = Dota2MinimapTower{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MinimapTower) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MinimapTower) ProtoMessage() {}

func (x *Dota2MinimapTower) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MinimapTower.ProtoReflect.Descriptor instead.
func (*Dota2MinimapTower) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{9}
}

func (x *Dota2MinimapTower) GetLane() Dota2Lane {
	if x != nil {
		return x.Lane
	}
	return Dota2Lane_DOTA2_LANE_UNSPECIFIED
}

func (x *Dota2MinimapTower) GetFaction() Dota2Faction {
	if x != nil {
		return x.Faction
	}
	return Dota2Faction_DOTA2_FACTION_UNSPECIFIED
}

func (x *Dota2MinimapTower) GetTier() Dota2TowerTier {
	if x != nil {
		return x.Tier
	}
	return Dota2TowerTier_DOTA2_TOWER_TIER_UNSPECIFIED
}

func (x *Dota2MinimapTower) GetAlive() bool {
	if x != nil {
		return x.Alive
	}
	return false
}

type Dota2MinimapBarrack struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Lane    Dota2Lane        `protobuf:"varint,1,opt,name=lane,proto3,enum=bragi.Dota2Lane" json:"lane,omitempty"`
	Faction Dota2Faction     `protobuf:"varint,2,opt,name=faction,proto3,enum=bragi.Dota2Faction" json:"faction,omitempty"`
	Type    Dota2BarrackType `protobuf:"varint,3,opt,name=type,proto3,enum=bragi.Dota2BarrackType" json:"type,omitempty"`
	Alive   bool             `protobuf:"varint,4,opt,name=alive,proto3" json:"alive,omitempty"`
}

func (x *Dota2MinimapBarrack) Reset() {
	*x = Dota2MinimapBarrack{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MinimapBarrack) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MinimapBarrack) ProtoMessage() {}

func (x *Dota2MinimapBarrack) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MinimapBarrack.ProtoReflect.Descriptor instead.
func (*Dota2MinimapBarrack) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{10}
}

func (x *Dota2MinimapBarrack) GetLane() Dota2Lane {
	if x != nil {
		return x.Lane
	}
	return Dota2Lane_DOTA2_LANE_UNSPECIFIED
}

func (x *Dota2MinimapBarrack) GetFaction() Dota2Faction {
	if x != nil {
		return x.Faction
	}
	return Dota2Faction_DOTA2_FACTION_UNSPECIFIED
}

func (x *Dota2MinimapBarrack) GetType() Dota2BarrackType {
	if x != nil {
		return x.Type
	}
	return Dota2BarrackType_DOTA2_BARRACK_TYPE_UNSPECIFIED
}

func (x *Dota2MinimapBarrack) GetAlive() bool {
	if x != nil {
		return x.Alive
	}
	return false
}

type Dota2MatchMessage_Payload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Payload:
	//	*Dota2MatchMessage_Payload_Snapshot
	//	*Dota2MatchMessage_Payload_Update
	Payload isDota2MatchMessage_Payload_Payload `protobuf_oneof:"payload"`
}

func (x *Dota2MatchMessage_Payload) Reset() {
	*x = Dota2MatchMessage_Payload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchMessage_Payload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchMessage_Payload) ProtoMessage() {}

func (x *Dota2MatchMessage_Payload) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchMessage_Payload.ProtoReflect.Descriptor instead.
func (*Dota2MatchMessage_Payload) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{0, 0}
}

func (m *Dota2MatchMessage_Payload) GetPayload() isDota2MatchMessage_Payload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (x *Dota2MatchMessage_Payload) GetSnapshot() *Dota2MatchSnapshot {
	if x, ok := x.GetPayload().(*Dota2MatchMessage_Payload_Snapshot); ok {
		return x.Snapshot
	}
	return nil
}

func (x *Dota2MatchMessage_Payload) GetUpdate() *Dota2MatchUpdate {
	if x, ok := x.GetPayload().(*Dota2MatchMessage_Payload_Update); ok {
		return x.Update
	}
	return nil
}

type isDota2MatchMessage_Payload_Payload interface {
	isDota2MatchMessage_Payload_Payload()
}

type Dota2MatchMessage_Payload_Snapshot struct {
	// Initial snapshot
	Snapshot *Dota2MatchSnapshot `protobuf:"bytes,1,opt,name=snapshot,proto3,oneof"`
}

type Dota2MatchMessage_Payload_Update struct {
	// Particular updates which are applied on property match_state in MatchState.
	Update *Dota2MatchUpdate `protobuf:"bytes,2,opt,name=update,proto3,oneof"`
}

func (*Dota2MatchMessage_Payload_Snapshot) isDota2MatchMessage_Payload_Payload() {}

func (*Dota2MatchMessage_Payload_Update) isDota2MatchMessage_Payload_Payload() {}

type Dota2MatchUpdate_Payload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Payload:
	//	*Dota2MatchUpdate_Payload_MatchState
	Payload isDota2MatchUpdate_Payload_Payload `protobuf_oneof:"payload"`
}

func (x *Dota2MatchUpdate_Payload) Reset() {
	*x = Dota2MatchUpdate_Payload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bragi_dota2_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Dota2MatchUpdate_Payload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Dota2MatchUpdate_Payload) ProtoMessage() {}

func (x *Dota2MatchUpdate_Payload) ProtoReflect() protoreflect.Message {
	mi := &file_bragi_dota2_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Dota2MatchUpdate_Payload.ProtoReflect.Descriptor instead.
func (*Dota2MatchUpdate_Payload) Descriptor() ([]byte, []int) {
	return file_bragi_dota2_proto_rawDescGZIP(), []int{2, 0}
}

func (m *Dota2MatchUpdate_Payload) GetPayload() isDota2MatchUpdate_Payload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (x *Dota2MatchUpdate_Payload) GetMatchState() *Dota2MatchState {
	if x, ok := x.GetPayload().(*Dota2MatchUpdate_Payload_MatchState); ok {
		return x.MatchState
	}
	return nil
}

type isDota2MatchUpdate_Payload_Payload interface {
	isDota2MatchUpdate_Payload_Payload()
}

type Dota2MatchUpdate_Payload_MatchState struct {
	MatchState *Dota2MatchState `protobuf:"bytes,1,opt,name=match_state,json=matchState,proto3,oneof"`
}

func (*Dota2MatchUpdate_Payload_MatchState) isDota2MatchUpdate_Payload_Payload() {}

var File_bragi_dota2_proto protoreflect.FileDescriptor

var file_bragi_dota2_proto_rawDesc = []byte{
	0x0a, 0x11, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2f, 0x64, 0x6f, 0x74, 0x61, 0x32, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x05, 0x62, 0x72, 0x61, 0x67, 0x69, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x12, 0x62, 0x72, 0x61,
	0x67, 0x69, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
	0xf9, 0x02, 0x0a, 0x11, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x75,
	0x72, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x55,
	0x72, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x38,
	0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x32, 0x0a, 0x0b, 0x64, 0x61, 0x74, 0x61,
	0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11, 0x2e,
	0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x0a, 0x64, 0x61, 0x74, 0x61, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3a, 0x0a, 0x07,
	0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e,
	0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x52,
	0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x1a, 0x80, 0x01, 0x0a, 0x07, 0x50, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x12, 0x37, 0x0a, 0x08, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44,
	0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
	0x74, 0x48, 0x00, 0x52, 0x08, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x31, 0x0a,
	0x06, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e,
	0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x48, 0x00, 0x52, 0x06, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x42, 0x09, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0xaf, 0x02, 0x0a, 0x12,
	0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68,
	0x6f, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x75, 0x72, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x55, 0x72, 0x6e, 0x12,
	0x1a, 0x0a, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x38, 0x0a, 0x09, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x32, 0x0a, 0x0b, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x62, 0x72, 0x61,
	0x67, 0x69, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0a, 0x64,
	0x61, 0x74, 0x61, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x39, 0x0a, 0x0d, 0x61, 0x6e, 0x6e,
	0x6f, 0x75, 0x6e, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x13, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x41, 0x6e, 0x6e, 0x6f, 0x75, 0x6e, 0x63,
	0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0d, 0x61, 0x6e, 0x6e, 0x6f, 0x75, 0x6e, 0x63, 0x65, 0x6d,
	0x65, 0x6e, 0x74, 0x73, 0x12, 0x37, 0x0a, 0x0b, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x73, 0x74,
	0x61, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x62, 0x72, 0x61, 0x67,
	0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x0a, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x61, 0x74, 0x65, 0x22, 0x9e, 0x01,
	0x0a, 0x10, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x12, 0x39, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61,
	0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x50, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x1a, 0x4f, 0x0a,
	0x07, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x39, 0x0a, 0x0b, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x53, 0x74, 0x61, 0x74, 0x65, 0x48, 0x00, 0x52, 0x0a, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74,
	0x61, 0x74, 0x65, 0x42, 0x09, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x9a,
	0x01, 0x0a, 0x0f, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x61,
	0x74, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x75, 0x72, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x55, 0x72, 0x6e, 0x12,
	0x3b, 0x0a, 0x0a, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61,
	0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72, 0x64,
	0x52, 0x0a, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x12, 0x2d, 0x0a, 0x07,
	0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e,
	0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x69, 0x6e, 0x69, 0x6d,
	0x61, 0x70, 0x52, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70, 0x22, 0x8f, 0x03, 0x0a, 0x14,
	0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62,
	0x6f, 0x61, 0x72, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x75, 0x72,
	0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x55, 0x72,
	0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x70, 0x5f, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6d, 0x61, 0x70, 0x50, 0x61, 0x75, 0x73, 0x65, 0x64,
	0x12, 0x22, 0x0a, 0x0d, 0x68, 0x6f, 0x6d, 0x65, 0x5f, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x75, 0x72,
	0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x68, 0x6f, 0x6d, 0x65, 0x54, 0x65, 0x61,
	0x6d, 0x55, 0x72, 0x6e, 0x12, 0x22, 0x0a, 0x0d, 0x61, 0x77, 0x61, 0x79, 0x5f, 0x74, 0x65, 0x61,
	0x6d, 0x5f, 0x75, 0x72, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x61, 0x77, 0x61,
	0x79, 0x54, 0x65, 0x61, 0x6d, 0x55, 0x72, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x68, 0x6f, 0x6d, 0x65,
	0x5f, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x68, 0x6f,
	0x6d, 0x65, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x77, 0x61, 0x79, 0x5f,
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x61, 0x77, 0x61,
	0x79, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x0c, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x62,
	0x72, 0x61, 0x67, 0x69, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x54, 0x79, 0x70, 0x65, 0x52, 0x0b, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x3a, 0x0a, 0x0b, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6d, 0x61, 0x70,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44,
	0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x70, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72,
	0x64, 0x52, 0x0a, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x4d, 0x61, 0x70, 0x12, 0x3e, 0x0a,
	0x0d, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x5f, 0x6d, 0x61, 0x70, 0x73, 0x18, 0x09,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74,
	0x61, 0x32, 0x4d, 0x61, 0x70, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x52,
	0x0c, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x4d, 0x61, 0x70, 0x73, 0x22, 0xdb, 0x01,
	0x0a, 0x12, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x61, 0x70, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62,
	0x6f, 0x61, 0x72, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x70, 0x5f, 0x6f, 0x72, 0x64, 0x65,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x6d, 0x61, 0x70, 0x4f, 0x72, 0x64, 0x65,
	0x72, 0x12, 0x36, 0x0a, 0x09, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x08, 0x67, 0x61, 0x6d, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x37, 0x0a, 0x09, 0x68, 0x6f, 0x6d,
	0x65, 0x5f, 0x74, 0x65, 0x61, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62,
	0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x54, 0x65, 0x61, 0x6d, 0x53, 0x63,
	0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x52, 0x08, 0x68, 0x6f, 0x6d, 0x65, 0x54, 0x65,
	0x61, 0x6d, 0x12, 0x37, 0x0a, 0x09, 0x61, 0x77, 0x61, 0x79, 0x5f, 0x74, 0x65, 0x61, 0x6d, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f,
	0x74, 0x61, 0x32, 0x54, 0x65, 0x61, 0x6d, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72,
	0x64, 0x52, 0x08, 0x61, 0x77, 0x61, 0x79, 0x54, 0x65, 0x61, 0x6d, 0x22, 0xb7, 0x02, 0x0a, 0x13,
	0x44, 0x6f, 0x74, 0x61, 0x32, 0x54, 0x65, 0x61, 0x6d, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f,
	0x61, 0x72, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x75, 0x72, 0x6e, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x74, 0x65, 0x61, 0x6d, 0x55, 0x72, 0x6e, 0x12, 0x2d,
	0x0a, 0x07, 0x66, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x13, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x46, 0x61, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x66, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a,
	0x08, 0x62, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x08, 0x62, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6b, 0x69, 0x6c,
	0x6c, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x12,
	0x1b, 0x0a, 0x09, 0x6e, 0x65, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x74, 0x68, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x08, 0x6e, 0x65, 0x74, 0x57, 0x6f, 0x72, 0x74, 0x68, 0x12, 0x18, 0x0a, 0x07,
	0x72, 0x6f, 0x73, 0x68, 0x61, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x72,
	0x6f, 0x73, 0x68, 0x61, 0x6e, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x74, 0x6f, 0x77, 0x65, 0x72, 0x73,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x74, 0x6f, 0x77, 0x65, 0x72, 0x73, 0x12, 0x15,
	0x0a, 0x03, 0x77, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x03, 0x77,
	0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x36, 0x0a, 0x07, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44,
	0x6f, 0x74, 0x61, 0x32, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62,
	0x6f, 0x61, 0x72, 0x64, 0x52, 0x07, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x42, 0x06, 0x0a,
	0x04, 0x5f, 0x77, 0x6f, 0x6e, 0x22, 0xdc, 0x02, 0x0a, 0x15, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x50,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x12,
	0x1d, 0x0a, 0x0a, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x75, 0x72, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x09, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x55, 0x72, 0x6e, 0x12, 0x17,
	0x0a, 0x07, 0x73, 0x6c, 0x6f, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x06, 0x73, 0x6c, 0x6f, 0x74, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x65, 0x78, 0x74, 0x5f, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x74, 0x4e, 0x61,
	0x6d, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x68, 0x65, 0x72, 0x6f, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x06, 0x68, 0x65, 0x72, 0x6f, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x68,
	0x61, 0x73, 0x5f, 0x61, 0x65, 0x67, 0x69, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
	0x68, 0x61, 0x73, 0x41, 0x65, 0x67, 0x69, 0x73, 0x12, 0x43, 0x0a, 0x0d, 0x72, 0x65, 0x73, 0x70,
	0x61, 0x77, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x65,
	0x73, 0x70, 0x61, 0x77, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x72, 0x88, 0x01, 0x01, 0x12, 0x18, 0x0a,
	0x07, 0x61, 0x73, 0x73, 0x69, 0x73, 0x74, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07,
	0x61, 0x73, 0x73, 0x69, 0x73, 0x74, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x65, 0x61, 0x74, 0x68,
	0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x12,
	0x14, 0x0a, 0x05, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05,
	0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x65, 0x74, 0x5f, 0x77, 0x6f, 0x72,
	0x74, 0x68, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x6e, 0x65, 0x74, 0x57, 0x6f, 0x72,
	0x74, 0x68, 0x42, 0x10, 0x0a, 0x0e, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x61, 0x77, 0x6e, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x72, 0x22, 0xd1, 0x01, 0x0a, 0x0c, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x69,
	0x6e, 0x69, 0x6d, 0x61, 0x70, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x75,
	0x72, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x55,
	0x72, 0x6e, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x70, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x6d, 0x61, 0x70, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12,
	0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x70, 0x5f, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x09, 0x6d, 0x61, 0x70, 0x50, 0x61, 0x75, 0x73, 0x65, 0x64, 0x12, 0x30,
	0x0a, 0x06, 0x74, 0x6f, 0x77, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18,
	0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x69, 0x6e, 0x69,
	0x6d, 0x61, 0x70, 0x54, 0x6f, 0x77, 0x65, 0x72, 0x52, 0x06, 0x74, 0x6f, 0x77, 0x65, 0x72, 0x73,
	0x12, 0x36, 0x0a, 0x08, 0x62, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b, 0x73, 0x18, 0x05, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32,
	0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70, 0x42, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b, 0x52, 0x08,
	0x62, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b, 0x73, 0x22, 0xa9, 0x01, 0x0a, 0x11, 0x44, 0x6f, 0x74,
	0x61, 0x32, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70, 0x54, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x24,
	0x0a, 0x04, 0x6c, 0x61, 0x6e, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x62,
	0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4c, 0x61, 0x6e, 0x65, 0x52, 0x04,
	0x6c, 0x61, 0x6e, 0x65, 0x12, 0x2d, 0x0a, 0x07, 0x66, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f,
	0x74, 0x61, 0x32, 0x46, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x66, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x29, 0x0a, 0x04, 0x74, 0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x15, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x54,
	0x6f, 0x77, 0x65, 0x72, 0x54, 0x69, 0x65, 0x72, 0x52, 0x04, 0x74, 0x69, 0x65, 0x72, 0x12, 0x14,
	0x0a, 0x05, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x61,
	0x6c, 0x69, 0x76, 0x65, 0x22, 0xad, 0x01, 0x0a, 0x13, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4d, 0x69,
	0x6e, 0x69, 0x6d, 0x61, 0x70, 0x42, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b, 0x12, 0x24, 0x0a, 0x04,
	0x6c, 0x61, 0x6e, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x62, 0x72, 0x61,
	0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4c, 0x61, 0x6e, 0x65, 0x52, 0x04, 0x6c, 0x61,
	0x6e, 0x65, 0x12, 0x2d, 0x0a, 0x07, 0x66, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61,
	0x32, 0x46, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x66, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x2b, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x17, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x2e, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x42, 0x61, 0x72,
	0x72, 0x61, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x14,
	0x0a, 0x05, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x61,
	0x6c, 0x69, 0x76, 0x65, 0x2a, 0x60, 0x0a, 0x0c, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x46, 0x61, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x19, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x46, 0x41,
	0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45,
	0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x46, 0x41, 0x43,
	0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x41, 0x44, 0x49, 0x41, 0x4e, 0x54, 0x10, 0x01, 0x12, 0x16,
	0x0a, 0x12, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x46, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f,
	0x44, 0x49, 0x52, 0x45, 0x10, 0x02, 0x2a, 0x63, 0x0a, 0x09, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x4c,
	0x61, 0x6e, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x4c, 0x41, 0x4e,
	0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12,
	0x12, 0x0a, 0x0e, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x4c, 0x41, 0x4e, 0x45, 0x5f, 0x54, 0x4f,
	0x50, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x4c, 0x41, 0x4e,
	0x45, 0x5f, 0x4d, 0x49, 0x44, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x4f, 0x54, 0x41, 0x32,
	0x5f, 0x4c, 0x41, 0x4e, 0x45, 0x5f, 0x42, 0x4f, 0x54, 0x10, 0x03, 0x2a, 0x92, 0x01, 0x0a, 0x0e,
	0x44, 0x6f, 0x74, 0x61, 0x32, 0x54, 0x6f, 0x77, 0x65, 0x72, 0x54, 0x69, 0x65, 0x72, 0x12, 0x20,
	0x0a, 0x1c, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x54, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x54, 0x49,
	0x45, 0x52, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00,
	0x12, 0x16, 0x0a, 0x12, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x54, 0x4f, 0x57, 0x45, 0x52, 0x5f,
	0x54, 0x49, 0x45, 0x52, 0x5f, 0x31, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x44, 0x4f, 0x54, 0x41,
	0x32, 0x5f, 0x54, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x54, 0x49, 0x45, 0x52, 0x5f, 0x32, 0x10, 0x02,
	0x12, 0x16, 0x0a, 0x12, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x54, 0x4f, 0x57, 0x45, 0x52, 0x5f,
	0x54, 0x49, 0x45, 0x52, 0x5f, 0x33, 0x10, 0x03, 0x12, 0x16, 0x0a, 0x12, 0x44, 0x4f, 0x54, 0x41,
	0x32, 0x5f, 0x54, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x54, 0x49, 0x45, 0x52, 0x5f, 0x34, 0x10, 0x04,
	0x2a, 0x73, 0x0a, 0x10, 0x44, 0x6f, 0x74, 0x61, 0x32, 0x42, 0x61, 0x72, 0x72, 0x61, 0x63, 0x6b,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x22, 0x0a, 0x1e, 0x44, 0x4f, 0x54, 0x41, 0x32, 0x5f, 0x42, 0x41,
	0x52, 0x52, 0x41, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45,
	0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a, 0x19, 0x44, 0x4f, 0x54, 0x41,
	0x32, 0x5f, 0x42, 0x41, 0x52, 0x52, 0x41, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52,
	0x41, 0x4e, 0x47, 0x45, 0x44, 0x10, 0x01, 0x12, 0x1c, 0x0a, 0x18, 0x44, 0x4f, 0x54, 0x41, 0x32,
	0x5f, 0x42, 0x41, 0x52, 0x52, 0x41, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4d, 0x45,
	0x4c, 0x45, 0x45, 0x10, 0x02, 0x42, 0x21, 0x0a, 0x0f, 0x63, 0x6f, 0x6d, 0x2e, 0x6f, 0x64, 0x64,
	0x69, 0x6e, 0x2e, 0x62, 0x72, 0x61, 0x67, 0x69, 0x5a, 0x0e, 0x6f, 0x64, 0x64, 0x69, 0x6e, 0x2e,
	0x67, 0x67, 0x2f, 0x62, 0x72, 0x61, 0x67, 0x69, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_bragi_dota2_proto_rawDescOnce sync.Once
	file_bragi_dota2_proto_rawDescData = file_bragi_dota2_proto_rawDesc
)

func file_bragi_dota2_proto_rawDescGZIP() []byte {
	file_bragi_dota2_proto_rawDescOnce.Do(func() {
		file_bragi_dota2_proto_rawDescData = protoimpl.X.CompressGZIP(file_bragi_dota2_proto_rawDescData)
	})
	return file_bragi_dota2_proto_rawDescData
}

var file_bragi_dota2_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_bragi_dota2_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_bragi_dota2_proto_goTypes = []interface{}{
	(Dota2Faction)(0),                 // 0: bragi.Dota2Faction
	(Dota2Lane)(0),                    // 1: bragi.Dota2Lane
	(Dota2TowerTier)(0),               // 2: bragi.Dota2TowerTier
	(Dota2BarrackType)(0),             // 3: bragi.Dota2BarrackType
	(*Dota2MatchMessage)(nil),         // 4: bragi.Dota2MatchMessage
	(*Dota2MatchSnapshot)(nil),        // 5: bragi.Dota2MatchSnapshot
	(*Dota2MatchUpdate)(nil),          // 6: bragi.Dota2MatchUpdate
	(*Dota2MatchState)(nil),           // 7: bragi.Dota2MatchState
	(*Dota2MatchScoreboard)(nil),      // 8: bragi.Dota2MatchScoreboard
	(*Dota2MapScoreboard)(nil),        // 9: bragi.Dota2MapScoreboard
	(*Dota2TeamScoreboard)(nil),       // 10: bragi.Dota2TeamScoreboard
	(*Dota2PlayerScoreboard)(nil),     // 11: bragi.Dota2PlayerScoreboard
	(*Dota2Minimap)(nil),              // 12: bragi.Dota2Minimap
	(*Dota2MinimapTower)(nil),         // 13: bragi.Dota2MinimapTower
	(*Dota2MinimapBarrack)(nil),       // 14: bragi.Dota2MinimapBarrack
	(*Dota2MatchMessage_Payload)(nil), // 15: bragi.Dota2MatchMessage.Payload
	(*Dota2MatchUpdate_Payload)(nil),  // 16: bragi.Dota2MatchUpdate.Payload
	(*timestamppb.Timestamp)(nil),     // 17: google.protobuf.Timestamp
	(DataStatus)(0),                   // 18: bragi.DataStatus
	(*Announcement)(nil),              // 19: bragi.Announcement
	(MatchStatusType)(0),              // 20: bragi.MatchStatusType
	(*durationpb.Duration)(nil),       // 21: google.protobuf.Duration
}
var file_bragi_dota2_proto_depIdxs = []int32{
	17, // 0: bragi.Dota2MatchMessage.timestamp:type_name -> google.protobuf.Timestamp
	18, // 1: bragi.Dota2MatchMessage.data_status:type_name -> bragi.DataStatus
	15, // 2: bragi.Dota2MatchMessage.payload:type_name -> bragi.Dota2MatchMessage.Payload
	17, // 3: bragi.Dota2MatchSnapshot.timestamp:type_name -> google.protobuf.Timestamp
	18, // 4: bragi.Dota2MatchSnapshot.data_status:type_name -> bragi.DataStatus
	19, // 5: bragi.Dota2MatchSnapshot.announcements:type_name -> bragi.Announcement
	7,  // 6: bragi.Dota2MatchSnapshot.match_state:type_name -> bragi.Dota2MatchState
	16, // 7: bragi.Dota2MatchUpdate.payload:type_name -> bragi.Dota2MatchUpdate.Payload
	8,  // 8: bragi.Dota2MatchState.scoreboard:type_name -> bragi.Dota2MatchScoreboard
	12, // 9: bragi.Dota2MatchState.minimap:type_name -> bragi.Dota2Minimap
	20, // 10: bragi.Dota2MatchScoreboard.match_status:type_name -> bragi.MatchStatusType
	9,  // 11: bragi.Dota2MatchScoreboard.current_map:type_name -> bragi.Dota2MapScoreboard
	9,  // 12: bragi.Dota2MatchScoreboard.previous_maps:type_name -> bragi.Dota2MapScoreboard
	21, // 13: bragi.Dota2MapScoreboard.game_time:type_name -> google.protobuf.Duration
	10, // 14: bragi.Dota2MapScoreboard.home_team:type_name -> bragi.Dota2TeamScoreboard
	10, // 15: bragi.Dota2MapScoreboard.away_team:type_name -> bragi.Dota2TeamScoreboard
	0,  // 16: bragi.Dota2TeamScoreboard.faction:type_name -> bragi.Dota2Faction
	11, // 17: bragi.Dota2TeamScoreboard.players:type_name -> bragi.Dota2PlayerScoreboard
	21, // 18: bragi.Dota2PlayerScoreboard.respawn_timer:type_name -> google.protobuf.Duration
	13, // 19: bragi.Dota2Minimap.towers:type_name -> bragi.Dota2MinimapTower
	14, // 20: bragi.Dota2Minimap.barracks:type_name -> bragi.Dota2MinimapBarrack
	1,  // 21: bragi.Dota2MinimapTower.lane:type_name -> bragi.Dota2Lane
	0,  // 22: bragi.Dota2MinimapTower.faction:type_name -> bragi.Dota2Faction
	2,  // 23: bragi.Dota2MinimapTower.tier:type_name -> bragi.Dota2TowerTier
	1,  // 24: bragi.Dota2MinimapBarrack.lane:type_name -> bragi.Dota2Lane
	0,  // 25: bragi.Dota2MinimapBarrack.faction:type_name -> bragi.Dota2Faction
	3,  // 26: bragi.Dota2MinimapBarrack.type:type_name -> bragi.Dota2BarrackType
	5,  // 27: bragi.Dota2MatchMessage.Payload.snapshot:type_name -> bragi.Dota2MatchSnapshot
	6,  // 28: bragi.Dota2MatchMessage.Payload.update:type_name -> bragi.Dota2MatchUpdate
	7,  // 29: bragi.Dota2MatchUpdate.Payload.match_state:type_name -> bragi.Dota2MatchState
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_bragi_dota2_proto_init() }
func file_bragi_dota2_proto_init() {
	if File_bragi_dota2_proto != nil {
		return
	}
	file_bragi_common_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_bragi_dota2_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchSnapshot); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchUpdate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchScoreboard); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MapScoreboard); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2TeamScoreboard); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2PlayerScoreboard); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2Minimap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MinimapTower); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MinimapBarrack); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchMessage_Payload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bragi_dota2_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Dota2MatchUpdate_Payload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_bragi_dota2_proto_msgTypes[6].OneofWrappers = []interface{}{}
	file_bragi_dota2_proto_msgTypes[7].OneofWrappers = []interface{}{}
	file_bragi_dota2_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*Dota2MatchMessage_Payload_Snapshot)(nil),
		(*Dota2MatchMessage_Payload_Update)(nil),
	}
	file_bragi_dota2_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*Dota2MatchUpdate_Payload_MatchState)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_bragi_dota2_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_bragi_dota2_proto_goTypes,
		DependencyIndexes: file_bragi_dota2_proto_depIdxs,
		EnumInfos:         file_bragi_dota2_proto_enumTypes,
		MessageInfos:      file_bragi_dota2_proto_msgTypes,
	}.Build()
	File_bragi_dota2_proto = out.File
	file_bragi_dota2_proto_rawDesc = nil
	file_bragi_dota2_proto_goTypes = nil
	file_bragi_dota2_proto_depIdxs = nil
}
